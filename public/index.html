<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ModelEyes HTTP Server Demo</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      line-height: 1.6;
    }
    h1 {
      color: #4a6ee0;
      border-bottom: 1px solid #eee;
      padding-bottom: 10px;
    }
    .card {
      background-color: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 4px;
      padding: 20px;
      margin-bottom: 20px;
    }
    .card h2 {
      margin-top: 0;
      color: #4a6ee0;
    }
    pre {
      background-color: #f1f1f1;
      padding: 10px;
      border-radius: 4px;
      overflow: auto;
    }
    button {
      background-color: #4a6ee0;
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
    }
    button:hover {
      background-color: #3a5bbf;
    }
    .status {
      margin-top: 15px;
      padding: 10px;
      border-radius: 4px;
      background-color: #f8f9fa;
      border: 1px solid #dee2e6;
    }
    .preview-box {
      border: 1px solid #dee2e6;
      border-radius: 4px;
      padding: 0;
      margin-top: 15px;
      background-color: white;
      min-height: 600px;
      position: relative;
      overflow: auto;
    }
    .preview-container {
      position: relative;
      margin: 0 auto;
      background-color: #f9f9f9;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    }
    .preview-element {
      position: absolute;
      border: 1px solid rgba(74, 110, 224, 0.5);
      background-color: rgba(255, 255, 255, 0.95);
      font-size: 12px;
      overflow: visible;
      box-sizing: border-box;
      transition: all 0.2s;
      z-index: 1;
    }
    .preview-element:hover {
      border-color: #4a6ee0;
      background-color: rgba(74, 110, 224, 0.05);
      z-index: 100;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
    }
    .preview-element.interactive {
      border-color: rgba(40, 167, 69, 0.5);
    }
    .preview-element.interactive:hover {
      border-color: #28a745;
      background-color: rgba(40, 167, 69, 0.05);
    }
    .preview-element-content {
      position: absolute;
      top: -18px;
      left: -1px;
      padding: 2px 4px;
      background-color: #4a6ee0;
      color: white;
      border-radius: 3px 3px 0 0;
      font-size: 9px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 100%;
      z-index: 2;
      opacity: 0.8;
    }
    .preview-element.interactive .preview-element-content {
      background-color: #28a745;
    }
    .preview-element-text {
      position: relative;
      padding: 4px;
      font-size: 11px;
      line-height: 1.3;
      text-align: left;
      max-width: 100%;
      max-height: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
      color: #333;
      z-index: 1;
    }
    .preview-controls {
      margin-bottom: 10px;
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .preview-zoom {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .zoom-btn {
      background-color: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 4px;
      padding: 5px 10px;
      cursor: pointer;
    }
    .collapse-btn {
      background-color: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 4px;
      padding: 5px 10px;
      cursor: pointer;
      margin-bottom: 5px;
      display: inline-block;
    }
    .collapse-btn:hover {
      background-color: #e9ecef;
    }
    .zoom-btn:hover {
      background-color: #e9ecef;
    }
    .success {
      color: #28a745;
    }
    .error {
      color: #dc3545;
    }
  </style>
</head>
<body>
  <h1>ModelEyes HTTP Server Demo</h1>
  
  <div class="card">
    <h2>Current UI State</h2>
    <p>This shows the current UI state captured by the Chrome extension.</p>
    <button id="refresh-btn">Refresh</button>
    <button class="collapse-btn" id="toggle-ui-state">Collapse/Expand JSON</button>
    <div class="status" id="status" style="display: none;"></div>
    <pre id="ui-state">No UI state available</pre>
  </div>
  
  <div class="card">
    <h2>Find Elements</h2>
    <p>Find elements in the current UI state based on criteria.</p>
    <div>
      <label for="element-type">Element Type:</label>
      <input type="text" id="element-type" placeholder="e.g., button, input, a">
    </div>
    <div>
      <label for="element-text">Element Text:</label>
      <input type="text" id="element-text" placeholder="Text content to match">
    </div>
    <div>
      <label for="interactable">Interactable Only:</label>
      <input type="checkbox" id="interactable">
    </div>
    <button id="find-btn">Find Elements</button>
    <button class="collapse-btn" id="toggle-find-results">Collapse/Expand JSON</button>
    <pre id="find-results">No results</pre>
    
    <h3>Visual Preview</h3>
    <p>This shows a visual representation of the found elements:</p>
    <div class="preview-controls">
      <div class="preview-zoom">
        <button class="zoom-btn" id="zoom-out">-</button>
        <span id="zoom-level">100%</span>
        <button class="zoom-btn" id="zoom-in">+</button>
      </div>
      <button class="zoom-btn" id="reset-view">Reset View</button>
    </div>
    <div class="preview-box" id="preview-box">
      <div class="preview-container" id="preview-container"></div>
      <div class="status" id="preview-status" style="display: none;"></div>
    </div>
  </div>
  
  <div class="card">
    <h2>Chrome Extension</h2>
    <p>To use this demo with the Chrome extension:</p>
    <ol>
      <li>Install the ModelEyes Chrome extension</li>
      <li>Open the extension popup</li>
      <li>Set the server URL to <code>http://localhost:3000</code></li>
      <li>Click "Capture UI State"</li>
      <li>Return to this page and click "Refresh" to see the captured state</li>
    </ol>
  </div>
  
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const refreshBtn = document.getElementById('refresh-btn');
      const uiStateElem = document.getElementById('ui-state');
      const statusElem = document.getElementById('status');
      const findBtn = document.getElementById('find-btn');
      const findResultsElem = document.getElementById('find-results');
      const previewBoxElem = document.getElementById('preview-box');
      const previewContainerElem = document.getElementById('preview-container');
      const previewStatusElem = document.getElementById('preview-status');
      
      // Function to create a visual preview of the found elements
      // Initialize zoom level
      let zoomLevel = 1;
      
      // Add event listeners for zoom controls
      document.getElementById('zoom-in').addEventListener('click', function() {
        zoomLevel *= 1.2;
        updateZoom();
      });
      
      document.getElementById('zoom-out').addEventListener('click', function() {
        zoomLevel /= 1.2;
        updateZoom();
      });
      
      document.getElementById('reset-view').addEventListener('click', function() {
        zoomLevel = 1;
        updateZoom();
      });
      
      // Function to update zoom
      function updateZoom() {
        document.getElementById('zoom-level').textContent = `${Math.round(zoomLevel * 100)}%`;
        const container = document.getElementById('preview-container');
        container.style.transform = `scale(${zoomLevel})`;
        container.style.transformOrigin = 'top left';
      }
      
      function createVisualPreview(elements) {
        // Clear the preview container
        previewContainerElem.innerHTML = '';
        
        if (!elements || elements.length === 0) {
          previewStatusElem.className = 'status';
          previewStatusElem.textContent = 'No elements found';
          previewStatusElem.style.display = 'block';
          previewContainerElem.appendChild(previewStatusElem);
          return;
        }
        
        // Hide the status
        previewStatusElem.style.display = 'none';
        
        // Get the preview box dimensions
        const previewBoxWidth = previewBoxElem.clientWidth - 40; // Subtract padding
        const previewBoxHeight = 600;
        
        // Find the bounds of all elements to calculate scaling
        let minX = Infinity;
        let minY = Infinity;
        let maxX = 0;
        let maxY = 0;
        
        elements.forEach(element => {
          if (element.bounds) {
            minX = Math.min(minX, element.bounds.x);
            minY = Math.min(minY, element.bounds.y);
            maxX = Math.max(maxX, element.bounds.x + element.bounds.width);
            maxY = Math.max(maxY, element.bounds.y + element.bounds.height);
          }
        });
        
        // Sort elements by z-index (parent elements first)
        elements.sort((a, b) => {
          // Sort by depth (parent elements first)
          const aDepth = a.id.split('-').length;
          const bDepth = b.id.split('-').length;
          return aDepth - bDepth;
        });
        
        // Calculate the content dimensions
        const contentWidth = maxX - minX;
        const contentHeight = maxY - minY;
        
        // Calculate the scale to fit the content
        const boxScaleX = previewBoxWidth / (contentWidth || 1);
        const boxScaleY = previewBoxHeight / (contentHeight || 1);
        const scale = Math.min(boxScaleX, boxScaleY) * 0.95; // 95% of the available space
        
        // Set the container size based on the scaled content
        const containerWidth = contentWidth * scale;
        const containerHeight = contentHeight * scale;
        previewContainerElem.style.width = `${containerWidth}px`;
        previewContainerElem.style.minWidth = `${containerWidth}px`;
        previewContainerElem.style.height = `${containerHeight}px`;
        previewContainerElem.style.minHeight = `${containerHeight}px`;
        
        // Create elements in the preview
        elements.forEach(element => {
          if (element.bounds) {
            // Create element with appropriate class
            const previewElement = document.createElement('div');
            // Set element class based on type and interactability
            let className = `preview-element`;
            if (element.interactable) {
              className += ' interactive';
            }
            
            // Add type-specific classes
            if (element.type === 'div') className += ' element-div';
            else if (element.type === 'span') className += ' element-span';
            else if (element.type === 'a') className += ' element-a';
            else if (element.type === 'button') className += ' element-button';
            else if (element.type === 'input') className += ' element-input';
            else if (element.type === 'img') className += ' element-img';
            else if (element.type === 'table') className += ' element-table';
            else if (element.type === 'tr') className += ' element-tr';
            else if (element.type === 'td') className += ' element-td';
            else if (element.type === 'h1') className += ' element-h1';
            
            previewElement.className = className;
            
            // Set proper attributes instead of just using title
            previewElement.setAttribute('data-id', element.id);
            previewElement.setAttribute('data-type', element.type);
            previewElement.setAttribute('data-interactable', element.interactable.toString());
            
            if (element.text) {
              previewElement.setAttribute('data-text', element.text);
            }
            
            if (element.bounds) {
              previewElement.setAttribute('data-x', element.bounds.x.toString());
              previewElement.setAttribute('data-y', element.bounds.y.toString());
              previewElement.setAttribute('data-width', element.bounds.width.toString());
              previewElement.setAttribute('data-height', element.bounds.height.toString());
            }
            
            // Add role attribute if available
            if (element.attributes && element.attributes.role) {
              previewElement.setAttribute('role', element.attributes.role);
            }
            
            // Calculate position and size relative to the container
            const left = (element.bounds.x - minX) * scale;
            const top = (element.bounds.y - minY) * scale;
            const width = Math.max(element.bounds.width * scale, 10); // Minimum width of 10px
            const height = Math.max(element.bounds.height * scale, 10); // Minimum height of 10px
            
            previewElement.style.left = `${left}px`;
            previewElement.style.top = `${top}px`;
            previewElement.style.width = `${width}px`;
            previewElement.style.height = `${height}px`;
            
            // Set element style based on its type
            if (element.type === 'h1') {
              previewElement.style.fontWeight = 'bold';
              previewElement.style.fontSize = '18px';
            } else if (element.type === 'a') {
              previewElement.style.color = '#0066cc';
              previewElement.style.textDecoration = 'underline';
            } else if (element.type === 'button') {
              previewElement.style.backgroundColor = '#f0f0f0';
              previewElement.style.borderRadius = '4px';
            } else if (element.type === 'input') {
              previewElement.style.backgroundColor = '#ffffff';
              previewElement.style.border = '1px solid #ccc';
            } else if (element.type === 'table') {
              previewElement.style.border = '1px solid #ddd';
            } else if (element.type === 'tr') {
              previewElement.style.borderBottom = '1px solid #eee';
            } else if (element.type === 'td') {
              previewElement.style.padding = '4px';
            }
            
            // Add element type label
            const elementInfo = document.createElement('div');
            elementInfo.className = 'preview-element-content';
            elementInfo.textContent = element.type;
            
            // Add element text content if available with proper formatting
            if (element.text && element.text.trim()) {
              let elementText = document.createElement('div');
              
              // Format text based on element type
              if (element.type === 'h1') {
                elementText = document.createElement('h1');
                elementText.style.margin = '0';
                elementText.style.padding = '0';
                elementText.style.fontSize = '16px';
              } else if (element.type === 'a') {
                elementText = document.createElement('a');
                elementText.style.color = '#0066cc';
                elementText.style.textDecoration = 'underline';
              } else {
                elementText.className = 'preview-element-text';
              }
              
              // Truncate very long text to prevent overwhelming the preview
              let displayText = element.text;
              if (displayText.length > 100) {
                displayText = displayText.substring(0, 97) + '...';
              }
              
              // Set text content
              elementText.textContent = displayText;
              
              // Adjust font size based on element size
              const textLength = element.text.length;
              const area = width * height;
              
              if (area < 1000) {
                elementText.style.fontSize = '9px';
              } else if (area < 5000) {
                elementText.style.fontSize = '10px';
              } else if (area < 10000) {
                elementText.style.fontSize = '11px';
              } else {
                elementText.style.fontSize = '12px';
              }
              previewElement.appendChild(elementText);
            }
            
            // Always add the type label
            previewElement.appendChild(elementInfo);
            
            // Add click handler to highlight the element
            previewElement.addEventListener('click', function(e) {
              e.stopPropagation();
              
              // Remove highlight from all elements
              document.querySelectorAll('.preview-element').forEach(el => {
                el.style.zIndex = null;
                el.style.boxShadow = null;
                el.style.outline = null;
              });
              
              // Highlight this element
              this.style.zIndex = '1000';
              this.style.boxShadow = '0 0 10px rgba(255, 0, 0, 0.5)';
              this.style.outline = '2px solid red';
              
              // Show element details in console
              console.log('Element details:', element);
            });
            
            // Add minimal tooltip with just the element type and ID
            previewElement.title = `${element.type} (${element.id})`;

            // Add to the preview container
            previewContainerElem.appendChild(previewElement);
          }
        });
      }
      
      // Toggle JSON collapse/expand
      document.getElementById('toggle-ui-state').addEventListener('click', function() {
        const uiStateElem = document.getElementById('ui-state');
        if (uiStateElem.style.display === 'none') {
          uiStateElem.style.display = 'block';
          this.textContent = 'Collapse JSON';
        } else {
          uiStateElem.style.display = 'none';
          this.textContent = 'Expand JSON';
        }
      });
      
      document.getElementById('toggle-find-results').addEventListener('click', function() {
        const findResultsElem = document.getElementById('find-results');
        if (findResultsElem.style.display === 'none') {
          findResultsElem.style.display = 'block';
          this.textContent = 'Collapse JSON';
        } else {
          findResultsElem.style.display = 'none';
          this.textContent = 'Expand JSON';
        }
      });
      
      // Refresh UI state
      refreshBtn.addEventListener('click', async function() {
        try {
          statusElem.style.display = 'none';
          refreshBtn.disabled = true;
          refreshBtn.textContent = 'Loading...';
          
          const response = await fetch('/api/ui-state');
          
          if (!response.ok) {
            throw new Error(`Server responded with status ${response.status}`);
          }
          
          const data = await response.json();
          
          // Format and display the UI state
          uiStateElem.textContent = JSON.stringify(data, null, 2);
          
          // Show success message
          statusElem.className = 'status success';
          statusElem.textContent = `Successfully loaded UI state with ${Object.keys(data.elements).length} elements`;
          statusElem.style.display = 'block';
        } catch (error) {
          // Show error message
          statusElem.className = 'status error';
          statusElem.textContent = `Error: ${error.message}`;
          statusElem.style.display = 'block';
          
          // Clear UI state
          uiStateElem.textContent = 'No UI state available';
        } finally {
          refreshBtn.disabled = false;
          refreshBtn.textContent = 'Refresh';
        }
      });
      
      // Find elements
      findBtn.addEventListener('click', async function() {
        try {
          findBtn.disabled = true;
          findBtn.textContent = 'Searching...';
          
          const type = document.getElementById('element-type').value;
          const text = document.getElementById('element-text').value;
          const interactable = document.getElementById('interactable').checked;
          
          const response = await fetch('/api/find-elements', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              type: type || undefined,
              text: text || undefined,
              interactable: interactable || undefined
            })
          });
          
          if (!response.ok) {
            throw new Error(`Server responded with status ${response.status}`);
          }
          
          const data = await response.json();
          
          // Format and display the results
          findResultsElem.textContent = JSON.stringify(data, null, 2);
          
          // Create visual preview of the found elements
          createVisualPreview(data.elements);
        } catch (error) {
          // Show error message
          findResultsElem.textContent = `Error: ${error.message}`;
          
          // Clear the preview
          previewContainerElem.innerHTML = '';
          previewStatusElem.className = 'status error';
          previewStatusElem.textContent = `Error: ${error.message}`;
          previewStatusElem.style.display = 'block';
        } finally {
          findBtn.disabled = false;
          findBtn.textContent = 'Find Elements';
        }
      });
    });
  </script>
</body>
</html>